.. This document was generated by tools/gen-cpydiff.py

Core language
=============

Classes
-------

.. _cpydiff_core_class_delnotimpl:

Special method __del__ not implemented for user-defined classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sample code::

    import gc
    
    
    class Foo:
        def __del__(self):
            print("__del__")
    
    
    f = Foo()
    del f
    
    gc.collect()

+-------------+-------------+
| CPy output: | uPy output: |
+-------------+-------------+
| ::          |             |
|             |             |
|     __del__ |             |
+-------------+-------------+

.. _cpydiff_core_class_mro:

Method Resolution Order (MRO) is not compliant with CPython
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Depth first non-exhaustive method resolution order

**Workaround:** Avoid complex class hierarchies with multiple inheritance and complex method overrides. Keep in mind that many languages don't support multiple inheritance at all.

Sample code::

    
    
    class Foo:
        def __str__(self):
            return "Foo"
    
    
    class C(tuple, Foo):
        pass
    
    
    t = C((1, 2, 3))
    print(t)

+-------------+---------------+
| CPy output: | uPy output:   |
+-------------+---------------+
| ::          | ::            |
|             |               |
|     Foo     |     (1, 2, 3) |
+-------------+---------------+

.. _cpydiff_core_class_supermultiple:

When inheriting from multiple classes super() only calls one class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** See :ref:`cpydiff_core_class_mro`

**Workaround:** See :ref:`cpydiff_core_class_mro`

Sample code::

    
    
    class A:
        def __init__(self):
            print("A.__init__")
    
    
    class B(A):
        def __init__(self):
            print("B.__init__")
            super().__init__()
    
    
    class C(A):
        def __init__(self):
            print("C.__init__")
            super().__init__()
    
    
    class D(B, C):
        def __init__(self):
            print("D.__init__")
            super().__init__()
    
    
    D()

+----------------+----------------+
| CPy output:    | uPy output:    |
+----------------+----------------+
| ::             | ::             |
|                |                |
|     D.__init__ |     D.__init__ |
|     B.__init__ |     B.__init__ |
|     C.__init__ |     A.__init__ |
|     A.__init__ |                |
+----------------+----------------+

.. _cpydiff_core_class_superproperty:

Calling super() getter property in subclass will return a property object, not the value
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sample code::

    
    
    class A:
        @property
        def p(self):
            return {"a": 10}
    
    
    class AA(A):
        @property
        def p(self):
            return super().p
    
    
    a = AA()
    print(a.p)

+---------------+----------------+
| CPy output:   | uPy output:    |
+---------------+----------------+
| ::            | ::             |
|               |                |
|     {'a': 10} |     <property> |
+---------------+----------------+

Functions
---------

.. _cpydiff_core_function_argcount:

Error messages for methods may display unexpected argument counts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Pycopy counts "self" as an argument.

**Workaround:** Interpret error messages with the information above in mind.

Sample code::

    try:
        [].append()
    except Exception as e:
        print(e)

+---------------------------------------------------+------------------------------------------------------------+
| CPy output:                                       | uPy output:                                                |
+---------------------------------------------------+------------------------------------------------------------+
| ::                                                | ::                                                         |
|                                                   |                                                            |
|     append() takes exactly one argument (0 given) |     function takes 2 positional arguments but 1 were given |
+---------------------------------------------------+------------------------------------------------------------+

.. _cpydiff_core_function_userattr:

User-defined attributes for functions are not supported
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Pycopy is highly optimized for memory usage.

**Workaround:** Use external dictionary, e.g. ``FUNC_X[f] = 0``.

Sample code::

    
    
    def f():
        pass
    
    
    f.x = 0
    print(f.x)

+-------------+------------------------------------------------------------+
| CPy output: | uPy output:                                                |
+-------------+------------------------------------------------------------+
| ::          | ::                                                         |
|             |                                                            |
|     0       |     Traceback (most recent call last):                     |
|             |       File "<stdin>", line 13, in <module>                 |
|             |     AttributeError: 'function' object has no attribute 'x' |
+-------------+------------------------------------------------------------+

Generator
---------

.. _cpydiff_core_generator_noexit:

Context manager __exit__() not called in a generator which does not run to completion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sample code::

    
    
    class foo(object):
        def __enter__(self):
            print("Enter")
    
        def __exit__(self, *args):
            print("Exit")
    
    
    def bar(x):
        with foo():
            while True:
                x += 1
                yield x
    
    
    def func():
        g = bar(0)
        for _ in range(3):
            print(next(g))
    
    
    func()

+-------------+-------------+
| CPy output: | uPy output: |
+-------------+-------------+
| ::          | ::          |
|             |             |
|     Enter   |     Enter   |
|     1       |     1       |
|     2       |     2       |
|     3       |     3       |
|     Exit    |             |
+-------------+-------------+

Runtime
-------

.. _cpydiff_core_locals:

Local variables aren't included in locals() result
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Pycopy doesn't maintain symbolic local environment, it is optimized to an array of slots. Thus, local variables can't be accessed by a name.

Sample code::

    
    
    def test():
        val = 2
        print(locals())
    
    
    test()

+----------------+--------------------------------------------------------------------------------------------+
| CPy output:    | uPy output:                                                                                |
+----------------+--------------------------------------------------------------------------------------------+
| ::             | ::                                                                                         |
|                |                                                                                            |
|     {'val': 2} |     {'test': <function test at 0x7fffffff>, '__name__': '__main__', '__file__': '<stdin>'} |
+----------------+--------------------------------------------------------------------------------------------+

.. _cpydiff_core_locals_eval:

Code running in eval() function doesn't have access to local variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Pycopy doesn't maintain symbolic local environment, it is optimized to an array of slots. Thus, local variables can't be accessed by a name. Effectively, ``eval(expr)`` in Pycopy is equivalent to ``eval(expr, globals(), globals())``.

Sample code::

    val = 1
    
    
    def test():
        val = 2
        print(val)
        eval("print(val)")
    
    
    test()

+-------------+-------------+
| CPy output: | uPy output: |
+-------------+-------------+
| ::          | ::          |
|             |             |
|     2       |     2       |
|     2       |     1       |
+-------------+-------------+

import
------

.. _cpydiff_core_import___all__:

__all__ attribute of modules/packages isn't processed by Pycopy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Pycopy employs simplified model, where ``from mod import *`` imports all names, except those starting with an underscore. This handling is compatible with CPython.

**Workaround:** Don't rely on __all__. For symbols which you don't want to be imported with ``from mod import *``, start their names with ``_``. You can still import such a symbol explicitly with ``from mod import _sym``.

Sample code::

    from modules.modall import *
    
    print([name for name in dir() if "foo" in name])

+-----------------------+----------------------+
| CPy output:           | uPy output:          |
+-----------------------+----------------------+
| ::                    | ::                   |
|                       |                      |
|     ['_foo3', 'foo1'] |     ['foo1', 'foo2'] |
+-----------------------+----------------------+

.. _cpydiff_core_import_path:

__path__ attribute of a package has a different type (single string instead of list of strings) in Pycopy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Pycopy does't support namespace packages split across filesystem. Beyond that, Pycopy's import system is highly optimized for minimal memory usage.

**Workaround:** Details of import handling is inherently implementation dependent. Don't rely on such details in portable applications.

Sample code::

    import modules
    
    print(modules.__path__)

+--------------------------------------------------------+-------------------------------+
| CPy output:                                            | uPy output:                   |
+--------------------------------------------------------+-------------------------------+
| ::                                                     | ::                            |
|                                                        |                               |
|     ['/mnt/hdd/projects/pycopy/tests/cpydiff/modules'] |     ../tests/cpydiff//modules |
+--------------------------------------------------------+-------------------------------+

.. _cpydiff_core_import_prereg:

Failed to load modules are still registered as loaded
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** To make module handling more efficient, it's not wrapped with exception handling.

**Workaround:** Test modules before production use; during development, use ``del sys.modules["name"]``, or just soft or hard reset the board.

Sample code::

    import sys
    
    try:
        from modules import foo
    except NameError as e:
        print(e)
    try:
        from modules import foo
    
        print("Should not get here")
    except NameError as e:
        print(e)

+-------------------------------+------------------------------+
| CPy output:                   | uPy output:                  |
+-------------------------------+------------------------------+
| ::                            | ::                           |
|                               |                              |
|     foo                       |     foo                      |
|     name 'xxx' is not defined |     name 'xxx' isn't defined |
|     foo                       |     Should not get here      |
|     name 'xxx' is not defined |                              |
+-------------------------------+------------------------------+

.. _cpydiff_core_import_split_ns_pkgs:

Pycopy does't support namespace packages split across filesystem.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cause:** Pycopy's import system is highly optimized for simplicity, minimal memory usage, and minimal filesystem search overhead.

**Workaround:** Don't install modules belonging to the same namespace package in different directories. For Pycopy, it's recommended to have at most 3-component module search paths: for your current application, per-user (writable), system-wide (non-writable).

Sample code::

    import sys
    
    sys.path.append(sys.path[1] + "/modules")
    sys.path.append(sys.path[1] + "/modules2")
    
    import subpkg.foo
    import subpkg.bar
    
    print("Two modules of a split namespace package imported")

+-------------------------------------------------------+-----------------------------------------------+
| CPy output:                                           | uPy output:                                   |
+-------------------------------------------------------+-----------------------------------------------+
| ::                                                    | ::                                            |
|                                                       |                                               |
|     Two modules of a split namespace package imported |     Traceback (most recent call last):        |
|                                                       |       File "<stdin>", line 13, in <module>    |
|                                                       |     ImportError: no module named 'subpkg.bar' |
+-------------------------------------------------------+-----------------------------------------------+

